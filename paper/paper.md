---
title: 'Openseize: A signal processing package for large EEG datasets in Python'
tags:
  - Python
  - EEG
  - neuroscience
  - signal processing
  - local field potentials
  - time series analysis
authors:
  - name: Matthew S. Caudill
    orcid: 0000-0002-3656-9261
    affiliation: "1, 2" # (multiple affiliations must be quoted)
  - name: Josh Baker
    orcid: 0000-0002-1403-1479
    affiliation: "2"
affiliations:
  - name: Department of Neuroscience, Baylor College of Medicine, Houston, TX, USA
    index: 1
  - name: Jan and Dan Duncan Neurological Research Institute at Texas Childrens Hospital, Houston, TX, USA
    index: 2
date: 8 November 2022
bibliography: paper.bib
---

# Summary

Electroencencepholgraphy (EEG) is an indispensable clinical and research
tool used to diagnose neurological disease and discover brain circuit mechanisms that support sensory, mnemonic and cognitive processing tasks. Mechanistically, EEGs are non-stationary time-series that capture the ongoing changes of the brain's electromagnetic field generated by millions of neurons communicating through small electric potentials at their synapses. To understand these time-series, linear digital signal processing (DSP) tools are routinely used to reduce noise, resample the data, remove artifacts, expose the data's spatio-temporal frequency content, and much more. 

# Statement of need

Current DSP software packages make two critical assumptions. The first assumption is that the signals to be analyzed are addressable to the analysis' machines memory. The second related assumption is that return values from a DSP process and all subsequent processes are also addressable to memory. Advances in recording technologies over the past decade are rapidly degrading these assumptions. Indeed, thin-film electronics innovations now allow for the deposition of a large number of electrode contacts onto a single recording device that can be left implanted in the brain for months. These long-duration and high-channel count recordings pose a serious challenge to current imperatively programmed DSP software. A survey of the source code of the most popular software packages indicate reliance on Matlab's or Scipy's DSP functions which necessitate in-memory arrays and implicitly force imperative style programming.

Â Openseize takes a functional (declarative) programming approach to DSP processing allowing for a constant and tunable memory overhead making Openseize scalable to the largest of EEG data-sets. Specifically, this approach shuttles iterables (called producers) rather than data between the processes within a program. Thus, a DSP pipeline is composed of sequences of producers that will produce DSP processed arrays lazily during an iteration protocol such as a for-loop \autoref{fig:pipeline}.

![Example DSP pipeline for computing the power spectrum of a large EEG dataset. Each DSP process in the pipeline recieves and returns a producer iterable. At the final stage the PSD estimator requests an array from the downsampled producer. This triggers all previous DSP producers to generate a single array.\label{fig: pipeline}](pipeline.png)

This functional programming approach has one constraint. All DSP algorithms in Openseize are by definition iterative. They must accept either an in-memory array or a producer of arrays and return new producers for other DSP processes. The iterative nature of each algorithm introduces a processing delay as data is moved from the file on disk to virtual memory. To reduce this delay, Openseize's algorithms routinely use a first-in first-out (FIFO)  data structure to cache data to reduce these transfers. The demonstration files included with Openseize make direct comparisons between Openseize's and Scipy's DSP algorithm operative times. 

In addition to scaling to large datasets, Openseize is built using an object-oriented approach to ensure extensibility. This feature, missing in many currently available DSP packages, is crucial in Neuroscientific research were many data storage formats are in use. Specifically, Openseize uses abstract base classes. These classes form a contract of sorts with future developers by making them aware of reusable methods already present in Openseize as well as concrete methods they must supply in order to analyze their data.

Finally, Openseize has an intuitive application programming interface (API). While under the hood, Openseize is using a functional approach, to the client or end-user, the calling of Openseize's functions are nearly identical to Scipy's DSP call signatures. The only noticeable difference is that the values from a process are not immediately returned. They are returned when a producer is iterated over. To create a consistent API, Openseize has avoided graphical user interfaces (GUIs). This decision reflects the fact that many current DSP packages have inconsistent APIs that provide a different functionality depending on whether the modules are invoked from the command-line or a GUI.   
